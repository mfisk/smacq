%start booleanline
%type <comp> booleanline

%{
#include <smacq.h>
static dts_comparison * Comp;
#define yyfilterlex yylex
%}

m4_include(grammer.y)

booleanline: boolean YYSTOP 	{
					Comp = $1;
					return 0;
				}
	;

%%

static dts_environment * tenv;
extern void yy_scan_string(char *);

static void print_comp(dts_environment * tenv, dts_comparison * c) {
	char * op;
	op = "UNDEFINED";

	if (!c) {
		// fprintf(stderr,". (%p)\n", c);
		return;
	}

	switch(c->op) {
		case AND: op = "AND"; break;
		case OR: op = "OR"; break;
		case GT: op = "<"; break;
		case LT: op = ">"; break;
		case EQ: op = "="; break;
		case NEQ: op = "!="; break;
		case GEQ: op = ">="; break;
		case LEQ: op = "<="; break;
		case EXIST: op = "exist"; break;
		case LIKE: op = "like"; break;
		case FUNC: op = "FN"; break;
	}

#if DEBUG
	switch(c->op) {
		case AND:
		case OR:
			fprintf(stderr, "Comparison %p: op %s, next %p, group %p\n", c, op, c->next, c->group);
			break;

		case FUNC:
			fprintf(stderr, "Comparison %p: FN %s(), next %p, group %p\n", c, c->valstr, c->next, c->group);
			break;

		default:
			fprintf(stderr, "Comparison %p: field %d... %s %s, next %p, group %p\n", c, c->field[0], op, c->valstr, c->next, c->group);
			break;
			
	}
#endif

	print_comp(tenv, c->group);
	print_comp(tenv, c->next);

}

dts_comparison * dts_parse_tests(dts_environment * localtenv, int argc, char ** argv) {
  dts_comparison * retval;
  int size = 1;
  int i;
  char * qstr;

  /* LOCK */
  tenv = localtenv;

  for (i=0; i<argc; i++) {
  	size += strlen(argv[i]);
  }
  size += argc;

  qstr = (char*)malloc(size);
  qstr[0] = '\0';
  	
  for (i=0; i<argc; i++) {
  	strcatn(qstr, size, argv[i]);
  	strcatn(qstr, size, " ");
  }
  yy_scan_string(qstr);
  //fprintf(stderr, "parsing filter buffer: %s\n", qstr); 

  if (yyfilterparse()) {
  	/* Should free the comparisons? */
        fprintf(stderr, "got nonzero return parsing boolean %s\n", qstr); 
  	return NULL;
  }

  retval = Comp;

  /* UNLOCK */
  print_comp(localtenv, retval);

  return retval;
}

void yyerror(char * msg) {
  fprintf(stderr, "Error: %s near %s\n", msg, yytext);
  //exit(-1);
}

#if 0
static struct list list_join(struct list list, struct list newl, int isor) {
	struct list retval;

	assert(newl.head);
	assert(list.head);

	if ((list.head == list.tail || list.isor == isor) && (newl.head == newl.tail || newl.isor == isor)) {
		/* Splice them together */
		assert(list.tail);
		list.tail->next = newl.head;

		retval.head = list.head;
		retval.tail = newl.head;
		retval.isor = isor;

		return retval;
	} else if (list.head == list.tail || list.isor == isor) {
		/* The right list (newl) is a different type, so make it a sublist */
		dts_comparison * comp = calloc(1,sizeof(dts_comparison));

		comp->op = newl.isor ? OR : AND;
		comp->group = newl.head;
		comp->next = NULL;

		list.tail = (list.tail->next = comp);
		list.isor = isor;

		return list;
	} else if (newl.head == newl.tail || newl.isor == isor) {
		/* The left list (list) is a different type, so make it a sublist */
		dts_comparison * comp = calloc(1,sizeof(dts_comparison));

		comp->op = list.isor ? OR : AND;
		comp->group = list.head;
		comp->next = newl.head;

		list.head = comp;
		list.tail = newl.tail;
		list.isor = isor;

		return list;
	} else {
		/* Both sublists are a different type, so make a new meta-list */
		dts_comparison * comp = calloc(1,sizeof(dts_comparison));
		dts_comparison * comp2 = calloc(1,sizeof(dts_comparison));

		comp->op = list.isor ? OR : AND;
		comp->group = list.head;
		comp->next = comp2;

		comp2->op = newl.isor ? OR : AND;
		comp2->group = newl.head;
		comp2->next = NULL;

		list.head = comp;
		list.tail = comp2;
		list.isor = isor;

		return list;
	}
}

static struct list newlist(char * field, dts_compare_operation op, char * value) {
     dts_comparison * comp = calloc(1,sizeof(dts_comparison));
     struct list list;

     comp->op = op;
     comp->valstr = value;
     comp->field = tenv->requirefield(tenv, field);

     list.head = comp;
     list.tail = comp;

     return list;
}
#endif


