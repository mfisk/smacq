#!/bin/sh

# This is a wrapper for g++ that tries to statically link any libraries
# that it can, with some specific exceptions.

dirs="/usr/lib"
args=`basename $0`" "

echo "Looking for static versions of libraries" 1>&2

findlib() {
	lib=`basename "$1"`
	dir=`dirname "$1"`
	case $lib in 
	   libc|libpthread|libdl|libintl)
			lib=`echo $lib | sed 's/lib/-l/'`
			echo "$lib"
			return 0
			;;
	esac

	for d in $dir $dirs; do 
		#ls $d/${lib}.a
		if [ -r $d/${lib}.a ]; then
			# Replace -l argument with explicit .a file
			res="-l:$d/${lib}.a"
			echo "Using $res for $lib" 1>&2

			if [ -r $d/$lib.so ]; then
				root=`ldd $d/$lib.so | cut -d= -f1 | sed 's/\..*//'`
				ldd $d/$lib.so | cut -d= -f1 | sed 's/\..*//' 1>&2
				for d in $root; do
					deps=`findlib $d`	
					if [ "$?" != "0" ]; then 
						echo 
						return 1
					fi

					if [ "$deps" != "" ]; then
						echo "Recursive dependency $deps" 1>&2
						res="$res $deps"
					fi
				done
                        fi
			echo "$res"
			return 1
		fi
		return 1 #No static version
	done
}

for word in "$@"; do
	sublib $word
done

sublib() {
	case $word in
		/*.so)
			root=`echo "$word" | sed 's/\.so//'`
			word=`findlib $root`
			;;
		/*.dylib)
			root=`echo "$word" | sed 's/\.dylib//'`
			word=`findlib $root`
			;;
		-l*)
			root=`echo "$word" | sed 's/^-l/lib/'`
			word=`findlib $root`
			;;
		-L*)
			dir=`echo "$word" | sed 's/^-L//'`
			dirs="$dir $dirs"
			;;
	esac

	args="$args$word "
}

# Remove our directory from the path
for f in `echo $PATH | sed 's/:/ /g'`; do 
	expr $f : '.*\/misc$' > /dev/null || newpath="$newpath$f:"
done
#echo $newpath 1>&2
PATH=$newpath
		
echo "$args"
$args
