.TH smacq-modules 3 "$Date: 2003/10/21 00:16:56 $" "LANL"
.SH NAME
smacq-modules - pipeline module programming guide
.SH SYNOPSIS
.nf
.B #include <smacq.h>
.fi

Each module must provide a statically defined structure of type struct smacq_functions named smacq_\fImodule\fP_table such as the following:
.sp
.BI "struct smacq_functions smacq_\fImodule\fP_table ="
.nf
.ne 7
.ta 8n 16n 32n
{
	produce: &smacq_\fImodule\fP_produce,
	consume: &smacq_\fImodule\fP_consume,
	init: &smacq_\fImodule\fP_init,
	shutdown: &smacq_\fImodule\fP_shutdown,
	algebra: {vector:1, boolean: 1, demux: 1}
};
.ta
.fi

.sp
By convention, the referenced functions also include the name of the module.  The API for each function is as follows:
.sp
.BI "static smacq_result smacq_\fImodule\fP_init(struct smacq_init * context);"
.sp
.BI "static smacq_result smacq_\fImodule\fP_consume(void * state, const dts_object *, int * outchan);"
.sp
.BI "static smacq_result smacq_\fImodule\fP_produce(void * state, const dts_object **, int * outchan);"
.sp
.BI "static smacq_result smacq_\fImodule\fP_shutdown(void * state);"
.sp

The algebra element is optional and is used only by the dataflow
optimizer.  The following elements of the algebra structure are as
follows:  Vector specifies that the module can be used with a single
input and a single output, or can be used with a vector of sets of
arguments separated by semicolons and a corresponding vector of output
channels.  Boolean specifies that the module merely filters out some
data and can be reordered in the dataflow by an optimizer.  Demux
specifies that the module demultiplexes output data among multiple
output chanels.  If a demux module fails to set the demux bit, then
the optimizer may produce disfunctional output.

.BI "static struct smacq_options smacq_options[];"
.fi
.SH DESCRIPTION

SMACQ(1) is an extensible component system for analyzing streams of
structured data.  This manpage describes the programming API for
creating pipeline modules.  Type modules are documented separately in
dts-types(3).

.sp

This document describes the programming interface used by authors of 
dataflow modules.  These modules are dynamically loaded and may be
instantiated multiple times.  Global and static variables are therefore
deprecated for most cases.
.sp
Each module must declare a \fBsmacq_\fP\fImodule\fP\fB_table\fP structure of type
\fBstruct smacq_functions\fP referring to static functions described below:
.sp
The \fBinit\fP function is called to initialize a new instantiate
of a module.  The return value is a module exit code, with 0 indicating no error.
All parameters are passed in a single structure:  
.sp
.RS
.nf
.ne 7
.ta 8n 16n 32n
struct smacq_init {
	int isfirst;
	int islast;
	char ** argv;
	int argc;
	smacq_environment * env;
	void * state;
	smacq_graph * self;
};
.ta
.fi
.RE
.sp
If any per-instantiation storage is required, it should
be allocated in \fBinit\fP and returned in the state parameter.  
The \fBenv\fP element should be saved and passed to any library functions
that require an argument of type \fBsmacq_environment\fP.
Arguments to the module are passed in standard argv, argc form.
This structure will be reused after \fBinit\fP returns, so anything you
wish to save out of it must be copied.
.sp
The \fBsmacq_produce()\fP function is called to output data from the
module.  It is passed the instantiation's state variable and a pointer
in which to store a pointer to a new data object.  The return code should be
SMACQ_PASS for success, SMACQ_END if there is no more data to be
produced (ever), or SMACQ_ERROR in case of error.  If there is more 
data to be produced, the result should be SMACQ_PASS|SMACQ_PRODUCE.
Produce is called for the first module in a pipeline, as well as right
before a shutdown.  Other than that, it is only called if the previous call 
to the mdoule (smacq_consume() or smacq_produce()) returned SMACQ_PRODUCE or SMACQ_CANPRODUCE.
SMACQ_PRODUCE requires that smacq_produce() be called before another consume, while
SMACQ_CANPRODUCE may or may not trigger an immediate call to smacq_produce().
.sp
The \fBsmacq_consume()\fP function is called when there is new data for
a module to process.  The return value signals what should be done
with the data.  The SMACQ_FREE value says that the data object no longer
needed.  SMACQ_PASS specifies that the structure should also be passed
to the next module (if there is one) in the pipeline.  SMACQ_ERROR
specifies that there was a fatal error consuming the packet.
SMACQ_PRODUCE signals that smacq_produce() must be called before
smacq_consume() can be called again.  SMACQ_CANPRODUCE says that
smacq_produce() will return data, but does not have to be called for
smacq_consume() (presumably your module is doing some kind of buffering
in this case).
.sp
Both \fBsmacq_consume\fP and \fBsmacq_produce()\fP may fill in the 
outchan parameter if they wish to limit the flow of data to a specific
child in the data-flow graph.  Otherwise, the default value of -1 will 
cause data to go to all children.
.sp
The \fBsmacq_shutdown()\fP function is called when there is no more data
to process.  It is responsible for freeing and resources used by the
module.  The return value is an exit code, with 0 indicating no error.

.SH LIBRARY 

See the \fBdts(3)\fP documentation for information on using dts_object objects.
	
.TP
.BI "int smacq_getoptsbyname(int argc, char ** argv, int * argc_left, char *** argv_left, struct smacq_options * options, struct smacq_optval * optvals)"
Parse the argv argument vector according to the legal options specified in
the \fIoptions\fP array and store the values in the memory locations
pointed to by the \fIoptvals\fP array. 
Each array is terminated with a structure with a NULL name.
.sp
.RS
.nf
.ne 7
.ta 8n 16n 32n
struct smacq_options {
	char * name;
	smacq_opt default_value;
	char * description;
	smacq_opt_type type;
	int flags;
};
.sp
struct smacq_optval {
	char * name;
	smacq_opt * location;
};
.ta
.fi
.sp
Valid types are: \fISMACQ_OPT_TYPE_INT, SMACQ_OPT_TYPE_USHORT, SMACQ_OPT_TYPE_TIMEVAL, SMACQ_OPT_TYPE_UINT32, SMACQ_OPT_TYPE_BYTES, SMACQ_OPT_TYPE_STRING, SMACQ_OPT_TYPE_UBYTE, SMACQ_OPT_TYPE_DOUBLE, SMACQ_OPT_TYPE_BOOLEAN \fP
.fi

.SH "OUTPUT QUEUES"

It is often necessary for modules to queue data objects for output.  The following routines enqueue and dequeue objects.  The
queue is a struct smacq_outputq * and is initialized to NULL.

.TP
.BI "void smacq_produce_enqueue(struct smacq_outputq ** qp, const dts_object * o, int outchan)"

.TP
.BI "smacq_result smacq_produce_dequeue(struct smacq_outputq ** qp, const dts_object ** o, int * outchan)"

.TP
.BI "smacq_result smacq_produce_canproduce(struct smacq_outputq ** qp)"

.SH "HASH TABLES"

.TP
.BI "enum chaining_boolean { CHAIN, NOCHAIN };"
.TP
.BI "enum free_boolean { FREE, NOFREE };"

.TP
.BI "struct iovec_hash * bytes_hash_table_new(int maxkeybytes, int flags)"

Flags can include CHAIN, NOCHAIN, FREE, NOFREE.  The default is CHAIN|NOFREE.

.TP
.BI "int bytes_hash_table_incrementv(struct iovec_hash * ht, struct iovec *, int count)"
.TP
.BI "int bytes_hash_table_setv(struct iovec_hash * ht, struct iovec *, int count,  gpointer value)"
.TP
.BI "gpointer bytes_hash_table_setv(struct iovec_hash * ht, struct iovec * keys, int count, gpointer value)"
.TP
.BI "gpointer bytes_hash_table_lookupv(struct iovec_hash * ht, struct iovec *, int)"
.TP
.BI "int bytes_hash_table_removev(struct iovec_hash * ht, struct iovec *, int)"
.TP
.BI "void bytes_hash_table_destroy(struct iovec_hash * ht)"
.TP
.BI "gint bytes_hash_table_getv(struct iovec_hash * ht, struct iovec * key, int keys, gpointer *oldkey, gpointer *current)"
.TP
.BI "void bytes_init_hash(guint32** randoms, int num, unsigned long prime)"

.TP
.BI "guint32 bytes_hashv(struct iovec *, int nvecs)"
.TP
.BI "void bytes_hash_table_foreach(struct iovec_hash * ht, GHFunc func, gpointer user_data)"
.TP
.BI "void bytes_hash_table_foreach_remove(struct iovec_hash * ht, GHRFunc func, gpointer user_data)"


.SH "THREAD SHIM"

The native module API described above is based on event-driven
callbacks.  However, a module can instead have its own thread 
and a read/write API from a while loop.  (Note that a module thread may be implemented as a non-preemptive co-routine).  To use a thread, the
module function table should be initialized as follows:

.sp
.BI "struct smacq_functions smacq_\fImodule\fP_table = SMACQ_THREADED_MODULE(smacq_\fImodule\fP_loop)"

The smacq_\fImodule\fP_loop function can use the following functions:

.TP
.BI "const dts_object * smacq_read(struct smacq_init * context)"

Returns a dts_object or NULL if there are no more objects to be read the loop should return.

.TP
.BI "void smacq_write(struct state * state, dts_object * datum, int outchan)"

.TP
.BI "void smacq_decision(struct smacq_init * context, const dts_object * datum, smacq_result result)"

.TP
.BI "int smacq_flush(struct smacq_init * context)"

Returns 0 normally, or 1 when no more objects can be written and the caller should return.

.SH "DYNAMIC ARRAYS"

.TP
.BI "void darray_init(struct darray * darray, int max_hint)"

Initialize the dynamic array based on the hint specifying the maximum number of elements expected.

.TP
.BI "void * darray_get(struct darray * darray, int element)"

Return the specified elment of the array.

.TP
.BI "void darray_set(struct darray * darray, unsigned int element, void * value)"

Set the specified element of the array to the given value.

.TP
.BI "void darray_free(struct darray * darray)"

Free all data associated with the array.

.SH "SEE ALSO"
.BR smacq(1),
.BR dts(3)

