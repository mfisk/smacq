.PP
.TH "DTS" 3 "11 Aug 2004" "SMACQ" \" -*- nroff -*-
.ad l
.nh
.SH NAME
DTS \- 
.SH SYNOPSIS
.br
.PP
\fC#include <dts.h>\fP
.PP
.SH "Detailed Description"
.PP 
DTS is a Dynamic Type System run-time environment. You probably only want one instance of the DTS for your entire program. Factory methods are used to construct DtsObjects, which are typed using the DTS. 
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBDTS\fP ()"
.br
.RI "\fIConstruct a new DTS. You probably only want your program to use pointers to a single instance for the whole program. \fP"
.ti -1c
.RI "int \fBfromstring\fP (dts_typeid, char *datastr, \fBDtsObject\fP data)"
.br
.ti -1c
.RI "int \fBdts_lt\fP (int type, void *p1, int len1, void *p2, int len2)"
.br
.ti -1c
.RI "int \fBmaxfield\fP ()"
.br
.in -1c
.PP
.RI "\fBFactory Methods\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "\fBDtsObject\fP \fBconstruct\fP (dts_typeid, void *data)"
.br
.RI "\fIConstruct a new object with a copy of the given data. The amount of data copied is determined by the requested typeid. \fP"
.ti -1c
.RI "\fBDtsObject\fP \fBconstruct_fromstring\fP (dts_typeid type, char *data)"
.br
.RI "\fIConstruct a new object with data parsed from the given string. The input string should be format accordingly for the given typeid. \fP"
.ti -1c
.RI "\fBDtsObject\fP \fBnewObject\fP (dts_typeid)"
.br
.RI "\fIReturn a new object of the given type. \fP"
.ti -1c
.RI "\fBDtsObject\fP \fBnewObject\fP (dts_typeid, int size)"
.br
.RI "\fIReturn a new object of the given type and size. \fP"
.ti -1c
.RI "\fBDtsObject\fP \fBreadObject\fP (struct pickle *pickle, int fd)"
.br
.in -1c
.in -1c
.PP
.RI "\fBField IDs\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "dts_field \fBrequirefield\fP (char *name)"
.br
.RI "\fIDtsObjects expose 0 or more fields (attributes) that can be accessed. Each field is assigned a numeric identifier, a dts_field, specific to this runtime environment. Fields names can be nested (e.g. 'foo.bar.baz') which translates to nested numeric IDs (e.g. '1.3.2'). It is recommended for performance that modules convert type names to IDs sparingly and cache results. Convert the given field name into a numeric identifier. \fP"
.ti -1c
.RI "char * \fBfield_getname\fP (dts_field f)"
.br
.RI "\fIReturn the name of the specified field. \fP"
.in -1c
.in -1c
.PP
.RI "\fBType IDs\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "dts_typeid \fBrequiretype\fP (const  char *name)"
.br
.RI "\fITypes are dynamically loaded classes. Each type is assigned a numeric identifier specific to this runtime environment. All DtsObjects are typed with these values. It is recommended for performance that modules convert type names to IDs sparingly and cache results. Load the specified type module (if it is not already loaded) and return the dynamically assigned numeric identifier for that type. \fP"
.ti -1c
.RI "dts_typeid \fBtypenum_byname\fP (const  char *name)"
.br
.RI "\fIIf the specified type module is already loaded, this result is the same as \fBrequiretype()\fP. Unlike \fBrequiretype()\fP, if the type is not loaded, -1 is returned. \fP"
.ti -1c
.RI "char * \fBtypename_bynum\fP (const  dts_typeid)"
.br
.RI "\fIReturn the name of the given type. \fP"
.ti -1c
.RI "dts_type * \fBtype_bynum\fP (const  dts_typeid id)"
.br
.RI "\fIReturn the type structure for the given type. \fP"
.ti -1c
.RI "int \fBtype_size\fP (const  dts_typeid type)"
.br
.RI "\fIReturn the size (in bytes) of the specified type. -1 if size is variable, -2 if type doesn't exist. \fP"
.in -1c
.in -1c
.PP
.RI "\fBInterface to data testing system\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "int \fBparsetest\fP (dts_comparison *comp, char *test)"
.br
.ti -1c
.RI "int \fBmatch\fP (\fBDtsObject\fP datum, dts_comparison *comps)"
.br
.ti -1c
.RI "dts_comparison * \fBparse_tests\fP (int argc, char **argv)"
.br
.ti -1c
.RI "dts_operand * \fBparse_expr\fP (int argc, char **argv)"
.br
.in -1c
.in -1c
.PP
.RI "\fBMessaging\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "void \fBsend_message\fP (\fBDtsObject\fP, dts_field_element, dts_comparison *)"
.br
.RI "\fISend the given object to the given field of all objects that satisfy the comparison. \fP"
.ti -1c
.RI "\fBDtsObject\fP \fBmsg_check\fP (\fBDtsObject\fP o, dts_field_element field)"
.br
.RI "\fICheck for a message for this obejct and field. \fP"
.in -1c
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "std::stack< \fBDtsObject\fP > \fBfreelist\fP"
.br
.RI "\fIThis freelist should only be used by the DtsObject implementation. When an object is freed, it can be put on the freelist instead of being destroyed. \fBnewObject()\fP will use objects on the freelist before constructing new objects. \fP"
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "int \fByysmacql_parse\fP ()"
.br
.ti -1c
.RI "int \fByyfilterparse\fP ()"
.br
.ti -1c
.RI "int \fByyexprparse\fP ()"
.br
.in -1c

.SH "Author"
.PP 
Generated automatically by Doxygen for SMACQ from the source code.
