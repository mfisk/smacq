.TH smacq-modules 3 "$Date: 2002/12/01 03:21:45 $" "LANL"
.SH NAME
smacq-modules - pipeline module programming guide
.SH SYNOPSIS
.nf
.B #include <smacq.h>
.sp 
Each module must provide the following functions and global variables:
.sp
.BI "static smacq_result flow_init(struct smacq_init * context);"
.sp
.BI "static smacq_result flow_consume(void * state, const dts_object *, int * outchan);"
.sp
.BI "static smacq_result flow_produce(void * state, const dts_object **, int * outchan);"
.sp
.BI "static smacq_result flow_shutdown(void * state);"
.sp
.BI "static struct smacq_options smacq_options[];"
.sp
.BI "struct smacq_functions smacq_\fImodule\fP_table ="
.nf
.ne 7
.ta 8n 16n 32n
{
	produce: &flow_produce,
	consume: &flow_consume,
	init: &flow_init,
	shutdown: &flow_shutdown
};
.ta
.fi
.fi
.SH DESCRIPTION

"Flow" is an extensible component system for analyzing streams of
structured data.  This manpage describes the programming API for
creating pipeline modules.  Type modules are documented separately in
dts-types(3).

.sp

This document describes the programming interface used by authors of 
dataflow modules.  These modules are dynamically loaded and may be
instantiated multiple times.  Global and static variables are therefore
deprecated for most cases.
.sp
Each module must declare a \fBflow_\fP\fImodule\fP\fB_table\fP structure of type
\fBstruct smacq_functions\fP referring to static functions described below:
.sp
The \fBflow_init()\fP function is called to initialize a new instantiate
of a module.  The return value is a module exit code, with 0 indicating no error.
All parameters are passed in a single structure:  
.sp
.RS
.nf
.ne 7
.ta 8n 16n 32n
struct smacq_init {
	int isfirst;
	int islast;
	char ** argv;
	int argc;
	smacq_environment * env;
	void * state;
	struct filter * self;
};
.ta
.fi
.RE
.sp
If any per-instantiation storage is required, it should
be allocated in \fBflow_init()\fP and returned in the state parameter.  
The \fBenv\fP element should be saved and passed to any library functions
that require an argument of type \fBsmacq_environment\fP.
Arguments to the module are passed in standard argv, argc form.
This structure will be reused after flow_init() returns, so anything you
wish to save out of it must be copied.
.sp
The \fBflow_produce()\fP function is called to output data from the
module.  It is passed the instantiation's state variable and a pointer
in which to store a pointer to a new datum.  The return code should be
SMACQ_PASS for success, SMACQ_END if there is no more data to be
produced (ever), or SMACQ_ERROR in case of error.  If there is more 
data to be produced, the result should be SMACQ_PASS|SMACQ_PRODUCE.
Produce is called for the first module in a pipeline, as well as right
before a shutdown.  Other than that, it is only called if the previous call 
to the mdoule (flow_consume() or flow_produce()) returned SMACQ_PRODUCE or SMACQ_CANPRODUCE.
SMACQ_PRODUCE requires that flow_produce() be called before another consume, while
SMACQ_CANPRODUCE may or may not trigger an immediate call to flow_produce().
.sp
The \fBflow_consume()\fP function is called when there is new data for
a module to process.  The return value signals what should be done
with the data.  The SMACQ_FREE value says that the datum is no longer
needed.  SMACQ_PASS specifies that the structure should also be passed
to the next module (if there is one) in the pipeline.  SMACQ_ERROR
specifies that there was a fatal error consuming the packet.
SMACQ_PRODUCE signals that flow_produce() must be called before
flow_consume() can be called again.  SMACQ_CANPRODUCE says that
flow_produce() will return data, but does not have to be called for
flow_consume() (presumably your module is doing some kind of buffering
in this case).
.sp
Both \fBflow_consume\fP and \fBflow_produce()\fP may fill in the 
outchan parameter if they wish to limit the flow of data to a specific
child in the data-flow graph.  Otherwise, the default value of -1 will 
cause data to go to all children.
.sp
The \fBflow_shutdown()\fP function is called when there is no more data
to process.  It is responsible for freeing and resources used by the
module.  The return value is an exit code, with 0 indicating no error.

.SH LIBRARY 

.fa
The following routines provide access to datum records:

.TP
.BI "const dts_object * flow_dts_construct(smacq_environment * env, int type, void * data)"
Return a new data object with contents copied from data.  This call only
works for fixed-size objects.

.TP
.BI "const dts_object * flow_alloc(smacq_environment * env, int datasize, int type)"
Return a new, empty data object large enough to hold \fIdatasize\fP bytes.  
Use \fIflow_requiretype()\fP to get a
type number.

.TP
.BI "const dts_object * dts_writable(smacq_environment * env, dts_object * obj)"
	Return a pointer to a writable version of the specified object.
	This operation invalidates the original object so it should not
	be used any further and should not be passed on to other modules.

.TP
.BI "int flow_datum_size(const dts_object * datum)"
	Return the size of the data

.TP
.BI "void * dts_getdata(const dts_object * datum)"
	Return a pointer to the data

.TP
.BI "int dts_gettype(const dts_object * datum)"
	Return the type of the data

.TP
.BI "int dts_decref(const dts_object * datum)"
	Decrement the reference counter of the object and free it
	if there are no more references.

.TP
.BI "int dts_incref(const dts_object * datum, int num)"
	Increment the reference counter of the object by \fInum\fP.

.RE
Data records are composed of named fields that can be accessed with the following functions:

.TP
.BI "int flow_getfield(smacq_environment * env, const dts_object * datum, int field, dts_object * data)"
.TP
.BI "int dts_getfield(dts_environment * env, const dts_object * datum, int field, dts_object * data)"
	Initialize the data object to point to the specified field of the datum.  The data object
	is only valid for the life of this datum.  A zero is returned on failure.

.TP
.BI "int flow_getfield_copy(smacq_environment * env, const dts_object * datum, int field, dts_object * field_data)
	Same as above, but return a copy of the field that must be freed, but that will outlive the datum.

.TP
.BI "int flow_requirefield(smacq_environment * env, char * tname)"
.TP
.BI "int dts_requirefield(dts_environment * env, char * tname)"
	Return the dynamically assigned numeric identifier for the given field name.

.RE
Data records and fields are dynamically typed objects (\fIdts_object\fP).  The following routines interface with the type system:

.TP
.BI "int flow_fromstring(smacq_environment * env, int type, char * value, dts_object * data)"
	Convert the string-form value into a typed data object of the specified type. 

.TP
.BI "int flow_presentdata(smacq_environment * env, dts_object * data, char * transform_type, void ** transform_ptr, int * transform_size)"
.TP
.BI "int dts_presentdata(dts_environment * env, dts_object * data, char * transform_type, void ** transform_ptr, int * transform_size)"
	Transform the data object to the specified transform.  All types should
	provide a "string" type.  A pointer to the resulting transform is stored
	in transform_ptr and transform_size is set to the size of the transformed data.
	It is the responsibility of the caller to free transforms when done.

.TP
.BI "int flow_requiretype(smacq_environment * env, char * type_name)"
.TP
.BI "int dts_requiretype(dts_environment * env, char * type_name)"
	Types are dynamically loaded classes.  Load the specified type module
	(if it is not already loaded) and return the dynamically assigned numeric
	identifier for that type.

.TP
.BI "int smacq_opt_typenum_byname(smacq_environment * env, char * name)"
	Return the dynamically assigned numeric type identifier for the 
	specified type name.  Returns -1 if the type is not loaded.
	This number will be consistent for the duration of this instantiation.  It is recommended
	for performance that modules call smacq_opt_type() sparingly and cache results.
	All datum structures are typed with these values.

.TP
.BI "char * dts_typename_bynum(smacq_environment * env, int num)"
	Returns the string name of the specified numeric type identifier.

.RE
The system knows how to compare typed objects using the following routines:

.TP
.BI "int flow_match(smacq_environment * env, const dts_object * datum, dts_comparison * comps, int same_types)"
	Compares the specified datum with the specified list of comparisions.
	Returns non-zero iff all of the comparisons are true.

.TP
.BI "int flow_parsetest(smacq_environment * env, dts_comparison * comparison, char * test)"
	Initialize the comparison based on the given comparison string of one
	of the following forms:

.sp
.nf
.ne 7
.ta 8n 16n 32n
	field<value
	field=value
	field!=value
.ta
.fi
.RE
	
.TP
.BI "int smacq_getoptsbyname(int argc, char ** argv, int * argc_left, char *** argv_left, struct smacq_options * options, struct smacq_optval * optvals)"
Parse the argv argument vector according to the legal options specified in
the \fIoptions\fP array and store the values in the memory locations
pointed to by the \fIoptvals\fP array. 
Each array is terminated with a structure with a NULL name.
.sp
.RS
.nf
.ne 7
.ta 8n 16n 32n
struct smacq_options {
	char * name;
	smacq_opt default_value;
	char * description;
	smacq_opt_type type;
	int flags;
};
.sp
struct smacq_optval {
	char * name;
	smacq_opt * location;
};
.ta
.fi
.sp
Valid types are: \fI SMACQ_TYPE_STRING, SMACQ_TYPE_INT, SMACQ_TYPE_DOUBLE, SMACQ_TYPE_BOOLEAN \fP
.fi

.RE
Fields can also be sent to other data records:

.TP
.BI "void flow_msg_send(smacq_environment * env, int field, dts_object * data, dts_comparison * comparisonList)"
	Send a specified field with value specified by data to any data records described
	by the criteria in the comparison list.

.TP
.BI "void dts_attach_field(const dts_object * current_object, int field, const dts_object * field_data)"
	Attach the field_data object as a field of the current object.

.RE

.SH "SEE ALSO"
.BR smacqp(1),
.BR dts-types(3)
