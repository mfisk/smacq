.TH smacq-modules 3 "$Date: 2003/01/05 04:44:33 $" "LANL"
.SH NAME
smacq-modules - pipeline module programming guide
.SH SYNOPSIS
.nf
.B #include <smacq.h>
.sp 
Each module must provide the following functions and global variables:
.sp
.BI "static smacq_result smacq_init(struct smacq_init * context);"
.sp
.BI "static smacq_result smacq_consume(void * state, const dts_object *, int * outchan);"
.sp
.BI "static smacq_result smacq_produce(void * state, const dts_object **, int * outchan);"
.sp
.BI "static smacq_result smacq_shutdown(void * state);"
.sp
.BI "static struct smacq_options smacq_options[];"
.sp
.BI "struct smacq_functions smacq_\fImodule\fP_table ="
.nf
.ne 7
.ta 8n 16n 32n
{
	produce: &smacq_produce,
	consume: &smacq_consume,
	init: &smacq_init,
	shutdown: &smacq_shutdown
};
.ta
.fi
.fi
.SH DESCRIPTION

"Flow" is an extensible component system for analyzing streams of
structured data.  This manpage describes the programming API for
creating pipeline modules.  Type modules are documented separately in
dts-types(3).

.sp

This document describes the programming interface used by authors of 
dataflow modules.  These modules are dynamically loaded and may be
instantiated multiple times.  Global and static variables are therefore
deprecated for most cases.
.sp
Each module must declare a \fBsmacq_\fP\fImodule\fP\fB_table\fP structure of type
\fBstruct smacq_functions\fP referring to static functions described below:
.sp
The \fBsmacq_init()\fP function is called to initialize a new instantiate
of a module.  The return value is a module exit code, with 0 indicating no error.
All parameters are passed in a single structure:  
.sp
.RS
.nf
.ne 7
.ta 8n 16n 32n
struct smacq_init {
	int isfirst;
	int islast;
	char ** argv;
	int argc;
	smacq_environment * env;
	void * state;
	smacq_graph * self;
};
.ta
.fi
.RE
.sp
If any per-instantiation storage is required, it should
be allocated in \fBsmacq_init()\fP and returned in the state parameter.  
The \fBenv\fP element should be saved and passed to any library functions
that require an argument of type \fBsmacq_environment\fP.
Arguments to the module are passed in standard argv, argc form.
This structure will be reused after smacq_init() returns, so anything you
wish to save out of it must be copied.
.sp
The \fBsmacq_produce()\fP function is called to output data from the
module.  It is passed the instantiation's state variable and a pointer
in which to store a pointer to a new datum.  The return code should be
SMACQ_PASS for success, SMACQ_END if there is no more data to be
produced (ever), or SMACQ_ERROR in case of error.  If there is more 
data to be produced, the result should be SMACQ_PASS|SMACQ_PRODUCE.
Produce is called for the first module in a pipeline, as well as right
before a shutdown.  Other than that, it is only called if the previous call 
to the mdoule (smacq_consume() or smacq_produce()) returned SMACQ_PRODUCE or SMACQ_CANPRODUCE.
SMACQ_PRODUCE requires that smacq_produce() be called before another consume, while
SMACQ_CANPRODUCE may or may not trigger an immediate call to smacq_produce().
.sp
The \fBsmacq_consume()\fP function is called when there is new data for
a module to process.  The return value signals what should be done
with the data.  The SMACQ_FREE value says that the datum is no longer
needed.  SMACQ_PASS specifies that the structure should also be passed
to the next module (if there is one) in the pipeline.  SMACQ_ERROR
specifies that there was a fatal error consuming the packet.
SMACQ_PRODUCE signals that smacq_produce() must be called before
smacq_consume() can be called again.  SMACQ_CANPRODUCE says that
smacq_produce() will return data, but does not have to be called for
smacq_consume() (presumably your module is doing some kind of buffering
in this case).
.sp
Both \fBsmacq_consume\fP and \fBsmacq_produce()\fP may fill in the 
outchan parameter if they wish to limit the flow of data to a specific
child in the data-flow graph.  Otherwise, the default value of -1 will 
cause data to go to all children.
.sp
The \fBsmacq_shutdown()\fP function is called when there is no more data
to process.  It is responsible for freeing and resources used by the
module.  The return value is an exit code, with 0 indicating no error.

.SH LIBRARY 

.fa
The following routines provide access to datum records:

.TP
.BI "const dts_object * smacq_dts_construct(smacq_environment * env, int type, void * data)"
Return a new data object with contents copied from data.  This call only
works for fixed-size objects.

.TP
.BI "const dts_object * smacq_alloc(smacq_environment * env, int datasize, int type)"
Return a new, empty data object large enough to hold \fIdatasize\fP bytes.  
Use \fIsmacq_requiretype()\fP to get a
type number.

.TP
.BI "const dts_object * dts_writable(smacq_environment * env, dts_object * obj)"
	Return a pointer to a writable version of the specified object.
	This operation invalidates the original object so it should not
	be used any further and should not be passed on to other modules.

.TP
.BI "int smacq_datum_size(const dts_object * datum)"
	Return the size of the data

.TP
.BI "void * dts_getdata(const dts_object * datum)"
	Return a pointer to the data

.TP
.BI "int dts_gettype(const dts_object * datum)"
	Return the type of the data

.TP
.BI "int dts_decref(const dts_object * datum)"
	Decrement the reference counter of the object and free it
	if there are no more references.

.TP
.BI "int dts_incref(const dts_object * datum, int num)"
	Increment the reference counter of the object by \fInum\fP.

.RE
Data records are composed of named fields that can be accessed with the following functions:

.TP
.BI "const dts_object * smacq_getfield(smacq_environment * env, const dts_object * datum, dts_field field, dts_object * scratch)"
.TP
.BI "const dts_object * dts_getfield(dts_environment * env, const dts_object * datum, dts_field field, dts_object * scratch)"
	Initialize the "data" object to point to the specified field of the datum.  The data object
	is only valid for the life of this datum.  dts_decref() must be used to free the object.  NULL is returned on failure.
	The scratch argument should be NULL.

.TP
.BI "const dts_object * smacq_getfield_copy(smacq_environment * env, const dts_object * datum, dts_field * scratch)
	Same as above, but return persistant data that will outlive the datum.  dts_decref() must be used
	to free the object.  NULL is returned on failure.
	The scratch argument should be NULL.

.TP
.BI "dts_field smacq_requirefield(smacq_environment * env, char * tname)"
.TP
.BI "dts_field dts_requirefield(dts_environment * env, char * tname)"
	Return the dynamically assigned identifier for the given field name.  This dts_field must be 
	freed with dts_field_free().

.TP
.BI "char * dts_fieldname_append(const char * base, const char * addition)"
	Return a newly allocated string containing the addition string appended to the 
	base string and separated by a period.

.TP
.BI "void dts_field_free(dts_field field)"
	Free the given dts_field data structure.

.RE
Data records and fields are dynamically typed objects (\fIdts_object\fP).  The following routines interface with the type system:

.TP
.BI "int smacq_fromstring(smacq_environment * env, int type, char * value, dts_object * data)"
	Convert the string-form value into a typed data object of the specified type. 

.TP
.BI "int smacq_requiretype(smacq_environment * env, char * type_name)"
.TP
.BI "int dts_requiretype(dts_environment * env, char * type_name)"
	Types are dynamically loaded classes.  Load the specified type module
	(if it is not already loaded) and return the dynamically assigned numeric
	identifier for that type.

.TP
.BI "int smacq_opt_typenum_byname(smacq_environment * env, char * name)"
	Return the dynamically assigned numeric type identifier for the 
	specified type name.  Returns -1 if the type is not loaded.
	This number will be consistent for the duration of this instantiation.  It is recommended
	for performance that modules call smacq_opt_type() sparingly and cache results.
	All datum structures are typed with these values.

.TP
.BI "char * dts_typename_bynum(smacq_environment * env, int num)"
	Returns the string name of the specified numeric type identifier.

.RE
The system knows how to compare typed objects using the following routines:

.TP
.BI "int smacq_match(smacq_environment * env, const dts_object * datum, dts_comparison * comps, int same_types)"
	Compares the specified datum with the specified list of comparisions.
	Returns non-zero iff all of the comparisons are true.

.TP
.BI "dts_comparison * dts_parse_tests(dts_environment * tenv, int argc, char ** argv)"
	Return the comparison(s) resulting from the given argument vector.
	Comparisons can include AND and OR statements, parentheses for grouping, and equality and inequality operators.
	
.TP
.BI "int smacq_getoptsbyname(int argc, char ** argv, int * argc_left, char *** argv_left, struct smacq_options * options, struct smacq_optval * optvals)"
Parse the argv argument vector according to the legal options specified in
the \fIoptions\fP array and store the values in the memory locations
pointed to by the \fIoptvals\fP array. 
Each array is terminated with a structure with a NULL name.
.sp
.RS
.nf
.ne 7
.ta 8n 16n 32n
struct smacq_options {
	char * name;
	smacq_opt default_value;
	char * description;
	smacq_opt_type type;
	int flags;
};
.sp
struct smacq_optval {
	char * name;
	smacq_opt * location;
};
.ta
.fi
.sp
Valid types are: \fI SMACQ_TYPE_STRING, SMACQ_TYPE_INT, SMACQ_TYPE_DOUBLE, SMACQ_TYPE_BOOLEAN \fP
.fi

.RE
Fields can also be sent to other data records:

.TP
.BI "void smacq_msg_send(smacq_environment * env, dts_field field, dts_object * data, dts_comparison * comparisonList)"
	Send a specified field with value specified by data to any data records described
	by the criteria in the comparison list.

.TP
.BI "void dts_attach_field(const dts_object * current_object, dts_field field, const dts_object * field_data)"
	Attach the field_data object as a field of the current object.

.RE

.SH "SEE ALSO"
.BR smacqp(1),
.BR dts-types(3)
