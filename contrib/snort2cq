#!/usr/bin/perl

#
# This script reads Snort rule (conf) files and translates rules
# into discrete queries in the query language used by SMACQ.
# This output can be piped to "smacqq -m" which will execute each
# query simulatenously.  The "-O" option for smacqq will cause
# the queries to be optimized before execution
#
# Snort terms that are not supported by SMACQ are ignored.  A Snort
# syntax file is output as /tmp/snortcq.conf.  This file can be used
# to benchmark Snort against SMACQ for the set of functionality common
# to both systems.
#
# This script takes a "-p <value>" option that causes rules to be
# probabilistically included with the given probability.  The default is 1.
#

#
# The following variable definitions will be used when parsing Snort rules:
#
$HOME_NET 	= "128.165.0.0/16";
$EXTERNAL_NET 	= "!$HOME_NET";
$SMACQ_INPUT 	= "pcapfile(/hog/traces/aa.80)";

############################################################################

sub notany($resultstr, $arg) {
  local($resultstr, $arg) = @_;

  if ($arg eq '') { return; }
  if ($arg eq 'any') { return; }
  
  $resultstr =~ s|ARG|$arg|g;

  push(@tests, $resultstr);
}

sub hex2octalstr() {
  local($hex) = @_;
  $res = '';

  while($hex) {
    if (! ($hex =~ /^(..) *(.*)$/)) { return $res; }
    $res .= '\\x' . $1;
    $hex = $2;
  }

  return $res;
}

if ($ARGV[0] eq "-p") {
	shift(@ARGV);
	$prob = $ARGV[0];
	shift(@ARGV);
} else {
	$prob = 1;
}

open(SNORT, ">/tmp/snortcq.conf") || die;
while(<>) {
  $srcip = '';
  $dstip = '';
  $srcport = '';
  $dstport = '';
  $proto = '';
  $ipid = '';
  $seq = '';
  $sid = '';
  @contents = ();

  chomp;
  s|\$EXTERNAL_NET|$EXTERNAL_NET|g;
  s|\$HOME_NET|$HOME_NET|g;
  s|\$HTTP_SERVERS|any|g;
  s|\$SQL_SERVERS|any|g;
  s|\$HTTP_PORTS|80|g;
  s|\$ORACLE_PORTS|any|g;
  s|\$SMTP|any|g;

  ($action,$proto,$srcip,$srcport,$dir,$dstip,$dstport,$criteria) = split(/\s+/, $_, 8);
  
  if ($action ne "alert") { next; }

  #This is a rule, but do we want it?
  if (rand() > $prob) { next; }

  @tests = ();

  if ($proto ne "ip") {
  	&notany("ipprotocol = 'ARG'", $proto);
  }

  $srcip =~ s|\[([^,]+),.*\]|$1|;
  $dstip =~ s|\[([^,]+),.*\]|$1|;

  $criteria =~ s|^\(\s*||;
  $criteria =~ s|\s*\)\s*$||;

  # Split on unescaped semicolons
  $criteria =~ s|([^\\]);|$1 ;|g;
  @crits = split(/[^\\];/, $criteria);
  
  $snortrule = "alert $proto $srcip $srcport -> $dstip $dstport (";

  foreach $test (@crits) {
    $test =~ s|^\s+||;
    $test =~ s|\s+$||;

    ($op,$arg) = split(/\s*:\s*/, $test, 2);
    $arg =~ s|^\"||;
    $arg =~ s|\"$||;
    if ($op eq "sid") { 
      $sid = $arg; 
      $snortrule .= "sid:$sid; ";
    } elsif ($op eq "dsize") {
      if ($arg =~ /^([<>=]+)(.*)$/) {
      	$op = $1;
	$arg = $2;
      }  else {
      	$op = "=";
      }
      #&notany("payloadsize $op 'ARG'", $arg);
      #$snortrule .= "dsize:$arg; ";
    } elsif (($op eq "content") || ($op eq "uricontent")) { 
      if ($arg =~ /^!/) { next; }
      $parsedcontent = $arg; 
      $parsedcontent =~ s/\|([^|]*)\|/&hex2octalstr($1)/eg;
      push(@contents, $parsedcontent);
      $snortrule .= "content:\"$arg\"; ";
    } elsif ($op eq "id") {
      #$snortrule .= "id:\"$arg\"; ";
      #$ipid = $arg;
    } elsif ($op eq "seq") {
      #$snortrule .= "seq:\"$arg\"; ";
      #$seq = $arg;
    } elsif ($op eq "msg" || $op eq "reference" || $op eq "classtype" || $op eq "rev" || $op eq "depth" || $op eq "nocase") {
      
    } else {
      print stderr "[$op:$arg] in %_\n";
    }
  }

  if (! (@contents || $ipid || $seq)) {
  	#Skip trivial rules
  	next;
  }

  # Skip duplicate matches since Snort is first-match only
  $rule = join('-', ($srcip, $dstip, $srcport, $dstport, $proto, $parsedcontent, $seq, $ipid));
  if ($seen{$rule}) { next; }
  $seen{$rule} = $sid;

  &notany("mask(srcip, 'ARG')", $srcip);
  &notany("mask(dstip, 'ARG')", $dstip);
  &notany("srcport = 'ARG'", $srcport);
  &notany("dstport = 'ARG'", $dstport);
  #&notany("seq = ARG", $seq);
  #&notany("ipid = ARG", $ipid);
  foreach $c (@contents) {
  	&notany("substr(payload, \"ARG\")", $c);
  }

  $q = "print sid, srcip, dstip, ts from (const('$sid', sid) from $SMACQ_INPUT";
  if (@tests) {
  	$q .= " where ";
  	$q .= join(' and ', @tests);
  }

  print "$q)\n";

  print SNORT "$snortrule msg:\"$sid\"; )\n";
}
	  
